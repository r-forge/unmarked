#include "matrix.h"
#include "algorithm.h"
#include "distributions.h"
#include "stat.h"
#include "la.h"
#include "lapack.h"
#include "ide.h"
#include "smath.h"
#include "mersenne.h"
#include "optimize.h"
#include <iostream>
#include <R.h>
#include <vector>


/* Create a class for phi matrices (functors). Then, during model instantiation,
   set the phi matrix to the appropriate functor for that model based on K.
   Maybe function pointers are better?
*/

// This is the transpose of the phi matrix in my notes.  ie., it is column
// stochastic
using namespace std;
using namespace scythe;
using std::vector;

class phiMatrix {
public:
    virtual Matrix<> operator() (const Matrix<>& phiParms) =0;
};

class phiMatrix4 : public phiMatrix {
public:
    Matrix<> operator() (const Matrix<>& phiParms)
    {
	const double s0 = phiParms(0), s1 = phiParms(1), s2 = phiParms(2), s3 = phiParms(3),
	    g01 = phiParms(4), g02 = phiParms(5), g12 = phiParms(6),
	    r10 = phiParms(7), r21 = phiParms(8), r20 = phiParms(9),
	    r32 = phiParms(10), r31 = phiParms(11);
	const double vals[16] = {s0, (1-s0)*g01, (1-s0)*(1-g01)*g02, (1-s0)*(1-g01)*(1-g02),
			   (1-s1)*(1-g12)*r10, s1, (1-s1)*g12, (1-s1)*(1-g12)*(1-r10),
			   (1-s2)*(1-r21)*r20, (1-s2)*r21, s2, (1-s2)*(1-r21)*(1-r20),
			   (1-s3)*(1-r32)*(1-r31), (1-s3)*(1-r32)*r31, (1-s3)*r32, s3};

	Matrix<> P(4, 4, vals);
	return P;
    }
};

class phiMatrix3 : public phiMatrix {
public:
    Matrix<> operator() (const Matrix<>& phiParms)
    {
	double s0 = phiParms(0), s1 = phiParms(1), s2 = phiParms(2),
	    g0 = phiParms(3), g1 = phiParms(4), r2 = phiParms(5);

	double vals[9] = {s0,        (1-s0)*g0,     (1-s0)*(1-g0),
			  (1-s1)*(1-g1), s1,        (1-s1)*g1,
			  (1-s2)*(1-r2), (1-s2)*r2,  s2};

	Matrix<> P(3, 3, vals);

	return P;
    }
};

class phiMatrix2 : public phiMatrix {
public:
    Matrix<> operator() (const Matrix<>& phiParms)
    {
	double s0 = phiParms(0), s1 = phiParms(1);

	double vals[4] = {s0,    1-s0,
			  1-s1,   s1};

	Matrix<> P(2, 2, vals);

	return P;
    }
};


class phiMatrix4p4 : public phiMatrix {
public:
    Matrix<> operator() (const Matrix<>& phiParms)
    {
	double s0 = phiParms(0), s = phiParms(1),
	    g = phiParms(2), r = phiParms(3);

/*	double vals[16] = {s0,     (1-s0)*g,    (1-s0)*g*g, 1-(s0 + (1-s0)*g + (1-s0)*g*g),
			   (1-s)*r,   s,   (1-s)*g, 1 - ((1-s)*r + s + (1-s)*g),
			   1 - ((1-s)*r + s + (1-s)*g), (1-s)*r, s, (1-s)*g,
			   1 - ((1-s)*r*r +(1-s)*r + s), (1-s)*r*r, (1-s)*r, s};
*/

	double vals[16] = {s0,    g,  g*g,   g*g*g,
			   r,     s,   g,     g*g,
			   r*r,    r,  s,      g,
			   r*r*r, r*r, r,      s};

	const Matrix<> P(4, 4, vals);

	const Matrix<> Pcolsums = ones(1,4) * P;

	for(unsigned int i = 0; i < 4; ++i)
	    P(_,i) = P(_,i)/Pcolsums(i);

	return(P);
    }
};

class phiMatrix4ar : public phiMatrix {
public:
    Matrix<> operator() (const Matrix<>& phiParms)
    {
	double s0 = phiParms(0), s1 = phiParms(1), s2 = phiParms(2),
	    s3 = phiParms(3), g0 = phiParms(4), g1 = phiParms(5),
	    g2 = phiParms(6), r1 = phiParms(7), r2 = phiParms(8),
	    r3 = phiParms(9);

	double vals[16] = {s0,    g0,    g0*g0,   g0*g0*g0,
			   r1,     s1,     g1,     g1*g1,
			   r2*r2,    r2,    s2,      g2,
			   r3*r3*r3, r3*r3, r3,      s3};

	const Matrix<> P(4, 4, vals);

	const Matrix<> Pcolsums = ones(1,4) * P;

	for(unsigned int i = 0; i < 4; ++i)
	    P(_,i) = P(_,i)/Pcolsums(i);

	return(P);
    }
};


class cumLogitPhiMatrix : public phiMatrix {
public:
    Matrix<> operator() (const Matrix<>& phiParms)
    {
	// There are K alphas (none for last state)
	// phiParm(0) is baseline alpha
	// phiParm(j) is sqrt(alpha(j) - alpha(j-1)) so that
	// alphas are increasing in j
//	Matrix<> alpha = phiParms(0, 0, K - 1, 0);
	double alpha[K];
	double beta = phiParms(K,0);

	alpha[0] = phiParms(0);
	Matrix<> alphaDiffs = phiParms(1, 0, K - 1, 0);
	alphaDiffs = alphaDiffs^2;

	for(unsigned int j = 1; j <= K - 1; ++j) {
	    alpha[j] = alpha[j - 1] + alphaDiffs(j - 1);
	}

#ifdef DEBUG
	cout << "phiParms:\n" << phiParms
	     << "alphaDiffs:\n" << alphaDiffs
	     << "\nalpha: \n" << Matrix<> (K, 1, alpha)
	     << "\nbeta: " << beta << endl;
#endif
	Matrix<> P(K + 1, K + 1, true, 0);

	// assign values columnwise
	// element (j,i) is Prob(Xt = j| Xt-1 = i)
	for(unsigned int i = 0; i <= K; i++) {
	    P(0,i) = plogis(alpha[0] + beta*i, 0, 1);
	    for(unsigned int j = 1; j < K; j++) {
		P(j,i) = plogis(alpha[j] + beta*i, 0, 1) -
		    plogis(alpha[j-1] + beta*i, 0, 1);
	    }
	    P(K,i) = 1 - sum(P(_,i));
	}
#ifdef DEBUG
	cout << "P:\n" << P << endl;
#endif
	return(P);
    }

    unsigned int K;
};
